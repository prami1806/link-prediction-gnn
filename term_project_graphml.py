# -*- coding: utf-8 -*-
"""Term-Project-GraphML.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xNihZALJrhtnuu1YhWTAgFkRp8o4er87
"""

!pip install torch-scatter -f https://data.pyg.org/whl/torch-1.12.1+cu113.html
!pip install torch-sparse -f https://data.pyg.org/whl/torch-1.12.1+cu113.html
!pip install torch-geometric
!pip install -q git+https://github.com/snap-stanford/deepsnap.git
!pip install ogb

import torch
import torch_geometric
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.loader import DataLoader
from torch_geometric.nn import SAGEConv
from torch_geometric.utils import negative_sampling

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

from ogb.linkproppred import PygLinkPropPredDataset
dataset = PygLinkPropPredDataset(name='ogbl-ddi')

# getting info on ddi dataset
ddi_graph = dataset[0]
ddi_graph.num_nodes

ddi_graph.num_edges

ddi_graph.is_undirected()

ddi_graph.num_node_features

ddi_graph.has_isolated_nodes()

ddi_graph.has_self_loops()

split_edges = dataset.get_edge_split()
train_edges, valid_edges, test_edges = split_edges['train'],split_edges['valid'],split_edges['test']

train_edges["edge"].shape[0]

valid_edges["edge"].shape[0]

valid_edges["edge_neg"].shape[0]

test_edges["edge"].shape[0]

valid_edges["edge_neg"].shape[0]

# for generating embeddings using GNN (using graphSAGE)
class GraphSAGE(torch.nn.Module):
  def __init__(self,conv,in_channels,hidden_channels,out_channels,num_layers,dropout):
    super(GraphSAGE,self).__init__()
    self.convs = torch.nn.ModuleList()
    assert (num_layers>=2), 'Have at least 2 layers'
    self.convs.append(conv(in_channels,hidden_channels,normalize=True))
    for l in range(num_layers - 2):
      self.convs.append(conv(hidden_channels,hidden_channels,normalize=True))
    self.convs.append(conv(hidden_channels,out_channels,normalize=True))
    self.num_layers = num_layers
    self.dropout = dropout

  def forward(self,x,edge_index,edge_attr):
    if edge_attr is not None:
      return self.forward_with_edge_attr(x,edge_index,edge_attr)
    for i in range(self.num_layers - 1):
      x = self.convs[i](x,edge_index)
      x = F.relu(x)
      x = F.dropout(x,p=self.dropout,training=self.training)
    x = self.convs[self.num_layers-1](x,edge_index,edge_attr)
    return x

graphsage_in_channels = 256
graphsage_hidden_channels = 256
graphsage_out_channels = 256
graphsage_num_layers = 2
dropout = 0.5

initial_node_embeddings = torch.nn.Embedding(ddi_graph.num_nodes, graphsage_in_channels).to(device)

graphsage_model = GraphSAGE(SAGEConv, graphsage_in_channels,
                            graphsage_hidden_channels,
                            graphsage_out_channels,
                            graphsage_num_layers,
                            dropout).to(device)

link_predictor_in_channels = graphsage_out_channels
link_predictor_hidden_channels = link_predictor_in_channels

# for link prediction using generated embeddings
class LinkPredictor(torch.nn.Module):
  def __init__(self,in_channels,hidden_channels,dropout,out_channels=1,
               concat=lambda x,y:x*y):
    super(LinkPredictor,self).__init__()
    self.model = nn.Sequential(nn.Linear(in_channels,hidden_channels),nn.ReLU(),
                               nn.Dropout(p=dropout),nn.Linear(hidden_channels,out_channels),nn.Sigmoid())
    self.concat = concat
  
  def forward(self,u,v):
    x = self.concat(u,v)
    return self.model(x)

link_predictor = LinkPredictor(in_channels=link_predictor_in_channels, 
                               hidden_channels=link_predictor_hidden_channels, 
                               dropout=dropout).to(device)

def train(graphsage_model, link_predictor, initial_node_embeddings, edge_index,
          pos_train_edges, optimizer, batch_size, edge_attr=None):
  total_loss, total_examples = 0,0
  graphsage_model.train()
  link_predictor.train()
  for pos_samples in DataLoader(pos_train_edges, batch_size, shuffle=True):
    optimizer.zero_grad()
    node_embeddings = graphsage_model(initial_node_embeddings,edge_index,edge_attr)
    neg_samples = negative_sampling(edge_index,
                                    num_nodes = initial_node_embeddings.size(0),
                                    num_neg_samples=len(pos_samples),
                                    method='dense')
    pos_preds = link_predictor(node_embeddings[pos_samples[:,0]],
                               node_embeddings[pos_samples[:,1]])
    neg_preds = link_predictor(node_embeddings[neg_samples[0]],
                               node_embeddings[neg_samples[1]])
    preds = torch.concat((pos_preds,neg_preds))
    labels = torch.concat((torch.ones_like(pos_preds),
                           torch.zeros_like(neg_preds)))
    loss = F.binary_cross_entropy(preds,labels)
    loss.backward()
    optimizer.step()
    num_examples = len(pos_preds)
    total_loss += loss.item()*num_examples
    total_examples += num_examples
  return total_loss/total_examples

lr = 0.005
batch_size = 65536
epochs = 50
eval_steps = 5

optimizer = torch.optim.Adam(list(graphsage_model.parameters()) + list(initial_node_embeddings.parameters()) + list(link_predictor.parameters()), lr=lr)

pos_valid_edges = valid_edges['edge'].to(device)
neg_valid_edges = valid_edges['edge_neg'].to(device)
pos_test_edges = test_edges['edge'].to(device)
neg_test_edges = test_edges['edge_neg'].to(device)

from ogb.linkproppred import Evaluator
evaluator = Evaluator(name = 'ogbl-ddi')

@torch.no_grad()
def test(graphsage_model, link_predictor, initial_node_embeddings, edge_index, pos_valid_edges, neg_valid_edges, pos_test_edges, neg_test_edges, batch_size, evaluator, edge_attr=None):
  graphsage_model.eval()
  link_predictor.eval()
  final_node_embeddings = graphsage_model(initial_node_embeddings, edge_index, edge_attr)
  pos_valid_preds = []
  for pos_samples in DataLoader(pos_valid_edges, batch_size):
    pos_preds = link_predictor(final_node_embeddings[pos_samples[:,0]],
                               final_node_embeddings[pos_samples[:,1]])
    pos_valid_preds.append(pos_preds.squeeze())
  pos_valid_pred = torch.cat(pos_valid_preds, dim=0) 
  neg_valid_preds = []
  for neg_samples in DataLoader(neg_valid_edges, batch_size):
    neg_preds = link_predictor(final_node_embeddings[neg_samples[:,0]],
                               final_node_embeddings[neg_samples[:,1]])
    neg_valid_preds.append(neg_preds.squeeze())
  neg_valid_pred = torch.cat(neg_valid_preds, dim=0)
  pos_test_preds = []
  for pos_samples in DataLoader(pos_test_edges, batch_size):
    pos_preds = link_predictor(final_node_embeddings[pos_samples[:,0]],
                               final_node_embeddings[pos_samples[:,1]])
    pos_test_preds.append(pos_preds.squeeze())
  pos_test_pred = torch.cat(pos_test_preds,dim=0)
  neg_test_preds = []
  for neg_samples in DataLoader(neg_test_edges, batch_size):
    neg_preds = link_predictor(final_node_embeddings[neg_samples[:,0]],
                               final_node_embeddings[neg_samples[:,1]])
    neg_test_preds.append(neg_preds.squeeze())
  neg_test_pred = torch.cat(neg_test_preds,dim=0)
  evaluator.K = 20
  valid_hits = evaluator.eval({'y_pred_pos':pos_valid_pred,'y_pred_neg':neg_valid_pred})
  test_hits = evaluator.eval({'y_pred_pos':pos_test_pred,'y_pred_neg':neg_test_pred})
  return valid_hits, test_hits


# visualize and plot results
import matplotlib.pyplot as plt
from tqdm import trange
epochs_bar = trange(1, epochs+1,desc='Loss n/a')
edge_index = ddi_graph.edge_index.to(device)
pos_train_edges = train_edges['edge'].to(device)
losses = []
valid_hits_list = []
test_hits_list = []
for epoch in epochs_bar:
  loss = train(graphsage_model, link_predictor, initial_node_embeddings.weight, edge_index, pos_train_edges, optimizer, batch_size)
  losses.append(loss)
  epochs_bar.set_description(f'Loss {loss:0.4f}')
  if epoch%eval_steps == 0:
    valid_hits, test_hits = test(graphsage_model, link_predictor, initial_node_embeddings.weight, edge_index, pos_valid_edges,neg_valid_edges, pos_test_edges, neg_test_edges, batch_size, evaluator)
    print()
    print(f'Epoch: {epoch}, Validation Hits@20: {valid_hits["hits@20"]:0.4f}, Test Hits@20: {test_hits["hits@20"]:0.4f}')
    valid_hits_list.append(valid_hits['hits@20'])
    test_hits_list.append(test_hits['hits@20'])
  else:
    valid_hits_list.append(valid_hits_list[-1] if valid_hits_list else 0)
    test_hits_list.append(test_hits_list[-1] if test_hits_list else 0)

plt.title(dataset.name + ": GraphSAGE")
plt.xlabel("Epoch")
plt.plot(losses, label="Training loss")
plt.plot(valid_hits_list, label="Validation Hits@20")
plt.plot(test_hits_list, label="Test Hits@20")
plt.legend()
plt.show()

