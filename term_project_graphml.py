# -*- coding: utf-8 -*-
"""Term-Project-GraphML.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xNihZALJrhtnuu1YhWTAgFkRp8o4er87

Project idea and some parts of the code (dataset loading, testing, plotting functions etc.) has been taken from 
https://colab.research.google.com/drive/1os_WzZBOl95z8zCaxDUWvVVKoLPYbUT5?usp=sharing 
(Predicting Drug-Drug Interactions using Graph Neural Networks
By Ananth Agarwal, Meg Richey, and Zeb Mehring)
"""

!pip install torch-scatter -f https://data.pyg.org/whl/torch-1.12.1+cu113.html
!pip install torch-sparse -f https://data.pyg.org/whl/torch-1.12.1+cu113.html
!pip install torch-geometric
!pip install -q git+https://github.com/snap-stanford/deepsnap.git
!pip install ogb

import torch
import torch_geometric
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.loader import DataLoader
from torch_geometric.nn import SAGEConv
from torch_geometric.utils import negative_sampling

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

from ogb.linkproppred import PygLinkPropPredDataset
dataset = PygLinkPropPredDataset(name='ogbl-ddi')

ddi_graph = dataset[0]

split_edges = dataset.get_edge_split()
train_edges, valid_edges, test_edges = split_edges['train'],split_edges['valid'],split_edges['test']

"""This part is done by us"""
class GraphSAGE(torch.nn.Module):
  def __init__(self,in_dim,hid_dim,out_dim):
    # 4-layer GNN, 2 post-processing layers
    super().__init__()
    self.s1 = SAGEConv(in_dim,hid_dim,normalize=True)
    self.s2 = SAGEConv(hid_dim,hid_dim,normalize=True)
    self.s3 = SAGEConv(hid_dim,hid_dim,normalize=True)
    self.s4 = SAGEConv(hid_dim,out_dim,normalize=True)
    self.l1 = nn.Linear(hid_dim,hid_dim)
    self.l2 = nn.Linear(hid_dim,out_dim)

  def forward(self,x,edge_index,edge_attr):
    x = self.s1(x,edge_index)
    x = F.relu(x)
    x = x + self.s2(x,edge_index) # Adding skip connection for SAGEConv layers
    x = F.relu(x)
    x = x + self.s3(x,edge_index)
    x = F.relu(x)
    x = x + self.s4(x,edge_index)
    x = F.relu(x)
    x = self.l1(x)
    x = F.relu(x)
    x = self.l2(x)
    x = F.relu(x)
    return x

graphsage_in_channels = 256
graphsage_hidden_channels = 256
graphsage_out_channels = 256

initial_node_embeddings = torch.nn.Embedding(ddi_graph.num_nodes, graphsage_in_channels).to(device)

graphsage_model = GraphSAGE(graphsage_in_channels,
                            graphsage_hidden_channels,
                            graphsage_out_channels).to(device)

link_predictor_in_channels = graphsage_out_channels
link_predictor_hidden_channels = link_predictor_in_channels

"""This part is done by us"""

class LinkPredictor(torch.nn.Module):
  def __init__(self,in_dim,hid_dim,out_dim=1):
    super().__init__()
    self.model = nn.Sequential(
      nn.Linear(in_dim,hid_dim),
      nn.Linear(hid_dim, hid_dim*2),
      nn.Linear(hid_dim*2,hid_dim),
      nn.Linear(hid_dim,out_dim),
      nn.Sigmoid()
    )

  def forward(self,g,h):
    x = g*h
    return self.model(x)

link_predictor = LinkPredictor(in_dim=link_predictor_in_channels, 
                               hid_dim=link_predictor_hidden_channels).to(device)

def train(graphsage_model, link_predictor, initial_node_embeddings, edge_index,
          pos_train_edges, optimizer, batch_size, edge_attr=None):
  total_loss, total_examples = 0,0
  graphsage_model.train()
  link_predictor.train()
  for pos_samples in DataLoader(pos_train_edges, batch_size, shuffle=True):
    optimizer.zero_grad()
    node_embeddings = graphsage_model(initial_node_embeddings,edge_index,edge_attr)
    neg_samples = negative_sampling(edge_index,
                                    num_nodes = initial_node_embeddings.size(0),
                                    num_neg_samples=len(pos_samples),
                                    method='dense')
    pos_preds = link_predictor(node_embeddings[pos_samples[:,0]],
                               node_embeddings[pos_samples[:,1]])
    neg_preds = link_predictor(node_embeddings[neg_samples[0]],
                               node_embeddings[neg_samples[1]])
    preds = torch.concat((pos_preds,neg_preds))
    labels = torch.concat((torch.ones_like(pos_preds),
                           torch.zeros_like(neg_preds)))
    loss = F.binary_cross_entropy(preds,labels)
    loss.backward()
    optimizer.step()
    num_examples = len(pos_preds)
    total_loss += loss.item()*num_examples
    total_examples += num_examples
  return total_loss/total_examples

lr = 0.005
batch_size = 65536
epochs = 50
eval_steps = 5

optimizer = torch.optim.Adam(list(graphsage_model.parameters()) + list(initial_node_embeddings.parameters()) + list(link_predictor.parameters()), lr=lr)

pos_valid_edges = valid_edges['edge'].to(device)
neg_valid_edges = valid_edges['edge_neg'].to(device)
pos_test_edges = test_edges['edge'].to(device)
neg_test_edges = test_edges['edge_neg'].to(device)

from ogb.linkproppred import Evaluator
evaluator = Evaluator(name = 'ogbl-ddi')

@torch.no_grad()
def test(graphsage_model, link_predictor, initial_node_embeddings, edge_index, pos_valid_edges, neg_valid_edges, pos_test_edges, neg_test_edges, batch_size, evaluator, edge_attr=None):
  graphsage_model.eval()
  link_predictor.eval()
  final_node_embeddings = graphsage_model(initial_node_embeddings, edge_index, edge_attr)
  pos_valid_preds = []
  for pos_samples in DataLoader(pos_valid_edges, batch_size):
    pos_preds = link_predictor(final_node_embeddings[pos_samples[:,0]],
                               final_node_embeddings[pos_samples[:,1]])
    pos_valid_preds.append(pos_preds.squeeze())
  pos_valid_pred = torch.cat(pos_valid_preds, dim=0) 
  neg_valid_preds = []
  for neg_samples in DataLoader(neg_valid_edges, batch_size):
    neg_preds = link_predictor(final_node_embeddings[neg_samples[:,0]],
                               final_node_embeddings[neg_samples[:,1]])
    neg_valid_preds.append(neg_preds.squeeze())
  neg_valid_pred = torch.cat(neg_valid_preds, dim=0)
  pos_test_preds = []
  for pos_samples in DataLoader(pos_test_edges, batch_size):
    pos_preds = link_predictor(final_node_embeddings[pos_samples[:,0]],
                               final_node_embeddings[pos_samples[:,1]])
    pos_test_preds.append(pos_preds.squeeze())
  pos_test_pred = torch.cat(pos_test_preds,dim=0)
  neg_test_preds = []
  for neg_samples in DataLoader(neg_test_edges, batch_size):
    neg_preds = link_predictor(final_node_embeddings[neg_samples[:,0]],
                               final_node_embeddings[neg_samples[:,1]])
    neg_test_preds.append(neg_preds.squeeze())
  neg_test_pred = torch.cat(neg_test_preds,dim=0)
  evaluator.K = 20
  valid_hits = evaluator.eval({'y_pred_pos':pos_valid_pred,'y_pred_neg':neg_valid_pred})
  test_hits = evaluator.eval({'y_pred_pos':pos_test_pred,'y_pred_neg':neg_test_pred})
  return valid_hits, test_hits

import matplotlib.pyplot as plt
from tqdm import trange
epochs_bar = trange(1, epochs+1,desc='Loss n/a')
edge_index = ddi_graph.edge_index.to(device)
pos_train_edges = train_edges['edge'].to(device)
losses = []
valid_hits_list = []
test_hits_list = []
for epoch in epochs_bar:
  loss = train(graphsage_model, link_predictor, initial_node_embeddings.weight, edge_index, pos_train_edges, optimizer, batch_size)
  losses.append(loss)
  epochs_bar.set_description(f'Loss {loss:0.4f}')
  if epoch%eval_steps == 0:
    valid_hits, test_hits = test(graphsage_model, link_predictor, initial_node_embeddings.weight, edge_index, pos_valid_edges,neg_valid_edges, pos_test_edges, neg_test_edges, batch_size, evaluator)
    print()
    print(f'Epoch: {epoch}, Validation Hits@20: {valid_hits["hits@20"]:0.4f}, Test Hits@20: {test_hits["hits@20"]:0.4f}')
    valid_hits_list.append(valid_hits['hits@20'])
    test_hits_list.append(test_hits['hits@20'])
  else:
    valid_hits_list.append(valid_hits_list[-1] if valid_hits_list else 0)
    test_hits_list.append(test_hits_list[-1] if test_hits_list else 0)

plt.title(dataset.name + ": GraphSAGE")
plt.xlabel("Epoch")
plt.plot(losses, label="Training loss")
plt.plot(valid_hits_list, label="Validation Hits@20")
plt.plot(test_hits_list, label="Test Hits@20")
plt.legend()
plt.show()

